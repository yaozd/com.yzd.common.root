
2017-12-11
订阅者规则：
1.心跳2分钟一次
2.如果15分钟之内没有心跳则从SubZSet集合中移除
==
订阅者集合过期时间1小时
接收的监听集合过期时间30分钟

======================
个人对Redis pub/sub机制在实际运用场景的理解
http://blog.csdn.net/canot/article/details/51975566
Redis 的pub/sub机制与23种设计模式中的观察者设计模式极为类似。但Redis对于这个机制的实现更为轻便和简结，没有观察者模式的那么复杂的逻辑考虑而仅仅需要通过两个Redis客户端配置channel即可实现，因此它也仅仅做了消息的”发布”和”订阅”的实现，而在实际处理这类场景时遇到的情况根本没有考虑到。

数据可靠性无法保证
一个redis-cli发布消息n个redis-cli接受消息。消息的发布是无状态的，即发布完消息后该redis-cli便在理会该消息是否被接受到，是否在传输过程中丢失，即对于发布者来说，消息是”即发即失”的.

扩展性太差

不能通过增加消费者来加快消耗发布者的写入的数据，如果发布者发布的消息很多，则数据阻塞在通道中已等待被消费着来消耗。阻塞时间越久，数据丢失的风险越大(网络或者服务器的一个不稳定就会导致数据的丢失)

资源消耗较高

在pub/sub中消息发布者不需要独占一个Redis的链接，而消费者则需要单独占用一个Redis的链接，在java中便不得独立出分出一个线程来处理消费者。这种场景一般对应这多个消费者，此时则有着过高的资源消耗。

对于如上的几种不足，如果在项目中需要考虑的话可以使用JMS来实现该功能。JMS提供了消息的持久化/耐久性等各种企业级的特性。如果依然想使用Redis来实现并做一些数据的持久化操作，则可以根据JMS的特性来通过Redis模拟出来.